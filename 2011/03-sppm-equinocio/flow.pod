=encoding utf8

=head1 OpenData::Flow - um Framework Para Fluxo de Dados

=head2 OpenData

Tudo começou com um e-mail na L<lista da SP-PM|http://sao-paulo.pm.org/lista>,
no qual se falou de "hackear" dados públicos. 
Isso virou uma idéia de produzir um framework para buscar e 
analisar dados públicos. 
Logo, o L<Thiago Rondon|http://www.maluco.com.br/blog/> montou um 
L<repositório no GitHub|https://github.com/maluco/OpenData-BR> e começou a 
rabiscar umas idéias de código.  O L<OpenData-BR|http://www.opendatabr.org/>
ainda tem um status de I<work in progress>, mas as expectativas e as
perspectivas são muito animadoras.
 
=head2 Primeiras Idéias

=head3 Buscar dados na web (scrape)

A primeira idéia a ser implementada foi a lógica de buscar dados na web. Na
lista, ou no canal #saopaulo.pm no irc.perl.org, surgiram as primeiras
indicações de sites onde a informação estava disponibilizada. Um dos sites
primariamente visados foi o
L<PortalTransparencia|http://www.portaltransparencia.gov.br/>, o site do
governo federal para promover a transparência nos dados do governo.

Seguindo a metodologia opensource I<"release early, release often">, o
projeto começou a disponibilizar código que - efetivamente - conseguia buscar
dados. No entanto, esse código inicialmente não fazia muitas provisões
para manutenção e extensão no futuro.

=head3 ETL - extract transform load

Surgiu então uma tentativa de modularizar melhor o B<OpenData-BR>, dividindo-o
em 3 tipos de componentes:

=head4 Extractors

Extratores de dados. Basicamente a idéia seria que todos os scrapers, sejam
web ou não, na forma que forem, seriam um tipo de Extractor.

=head4 Transformers

Robôs assassinos que se transformam em carros ou outras máquinas fantásticas.
OK, não precisavam rir mesmo. Componentes que iriam conter toda a lógica de
B<transformação> dos dados, dos documentos originais para os dados buscados.

=head4 Loaders

Seriam os I<end-points> do processo de extração dos dados, e a principal
tarefa de um I<Loader> seria gravar os dados em algum lugar. Os primeiros
testes gravavam esses daods em um banco de dados MongoDB, ou imprimiam os
dados obtidos usando o L<Data::Dumper> (para debug).

=back

=head3 Flow, Baby, Flow

Quanto mais pensávamos no framework, mais ele se parecia com um fluxo de dados,
do começo (extractors) ao meio (transformers), ao fim (loaders).
Todos os componentes pareciam, de uma forma genérica, ter o mesmo
comportamento: recebe algo na entrada, faz alguma coisa com esses dados, e
(eventualmente) disponibiliza esses dados em uma saída.
Assim surgiu a idéia de fazer um sub-projeto de fluxo de dados.

Em meados de Dezembro de 2010, a primeira idéia foi codificada em termos de
"caixas", que teriam um entrada e uma saída - de uma forma bem genérica: 
"entra porquinho, sai salsicha".

=for picture: porquinho -> caixa -> salsicha

E as caixas poderiam ser enfileiradas para que a salsicha de um pudesse virar
a feijoada do próximo.

Assim surgiu, dentro do repositório do B<OpenData>, o sub-projeto que foi,
inicialmente, denominado de I<"Box">. Depois se tornou o I<"Flow"> e, enquanto
escrevo este artigo, tornou-se um projeto independente, o I<"DataFlow">.

=head2 Show Me The Node

B<DISCLAIMER>: O L<DataFlow> é um projeto que está em um estágio muito novo
do seu desenvolvimento, e por enquanto não há promessas ou garantias de que
as interfaces serão mantidas. Se há interesse em usar o DataFlow, sugiro
acompanhar de perto o desenvolvimento do mesmo para ficar a par de quaisquer
mudanças.

Um exemplo básico de um node que transforma os dados para caixa-alta (
I<upper-case>), usando a função C<< uc() >> padrão do Perl.

    my $uc = DataFlow::Node->new(
        process_item => sub {
            shift; return uc(shift);
        }
    );

Isso é um I<node> que irá transformar os itens fornecidos para caixa-alta. As
próximas perguntas são: Como eu uso? O que eu posso passar para esse node? As
respostas são:

    # em duas etapas
    $uc->input( 'laranja' );
    my $out = $uc->output();  # LARANJA

    # ou em um unica etapa
    my $out = $uc->process('laranja');

    # podemos passar arrays
    my @out = $uc->process( qw/feira da fruta/ ); # qw/FEIRA DA FRUTA/

    # podemos passar referencias
    my $out = $uc->process( [ 'oh', 'my', 'god' ] );

B<PEGADINHA>: nesta última forma, os elementos do ArrayRef C<não> serão
transformados, pois você pode ter um node que espera de fato uma I<reference>
e a trata de acordo com suas próprias regras. O mesmo se aplica a outros tipos
de referência. Se você quer que o node processe a informação B<dentro> da
referência, use:

    my $uc = DataFlow::Node->new(
        process_into => 1,
        process_item => sub {
            shift; return uc(shift);
        }
    );

    my $out = $uc->process( [ qw/oh my god/ ] );
    # resultado: [ 'OH', 'MY', 'GOD' ]

    my $ou = $uc->process( { a => 'value', another => 'different value' } );
    # resultado { a => 'VALUE', another => 'DIFFERENT VALUE' } );
    
Também podemos passar I<code references> para serem processadas (usando o
C<process_into>):

    my $code = sub { return 'batatas' };
    my $out = $uc->process( $code );
    print $out->(); # imprime 'BATATAS'

Notem que, quando são passadas referências, sempre são retornadas referências
do mesmo tipo. Neste último caso C<$out> contém um I<code reference> que,
ao ser invocado, aplica a função C<uc()> ao resultado do I<code reference>
passado ao node.

=head3 Chains

Um node sozinho não faz um hack, então é preciso "enfileirar" os nodes para
conseguir obter um resultado significativo. Para isso temos a classe
C<DataFlow::Node::Chain>, que pode ser usada assim:

    my $uc = DataFlow::Node->new(
        process_item => sub { shift; return uc(shift) }
    );
    my $rv = DataFlow::Node->new(
        process_item => sub { shift; return scalar reverse $_[0]; }
    );
    my $chain = DataFlow::Node::Chain->new( links => [ $uc, $rv ] );

Um objeto da classe C<Chain> é também um C<Node>

=head3 Biblioteca de Nós

Algumas operações são mais comuns, e nodes especializados podem ser criados
para executar processamentos específicos:

=over

=item 

=back

=head2 E Pra Que serve Tudo Isso?



=head2 Referências

=over

=item * Portal Transparência (L<http://www.portaltransparencia.gov.br/>)

=back

=head2 Agradecimentos

=over

=item Thiago "Maluco" Rondon - E<lt> thiago em aware ponto com ponto br E<gt>

Pelos testes, pelas idéias e pelas dicussões em horários excusos. Muitas das
idéias do L<DataFlow> germinaram a partir desses momentos.

=head2 Autor

Alexei "Russo" Znamensky - E<lt> russoz no cpan org E<gt>

Blog: L<http://russoz.wordpress.com/>

LinkedIn:
L<http://www.linkedin.com/profile?viewProfile=&key=754668&trk=tab_pro>

=head2 Licença

Este texto está licenciado sob os termos da Creative Commons by-sa,
L<http://creativecommons.org/licenses/by-sa/3.0/br/>

=begin pod:xhtml

<center>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/br/"><img alt="Licença Creative Commons" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/br/">Creative Commons Attribution-ShareAlike License</a>.
</center>

=end pod:xhtml

=cut

